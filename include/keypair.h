// keypair.h -- Public/Private Key Pair Wrapper
//
// ISC License
// 
// Copyright (C) 2018 Farid Hajji <farid@hajji.name>
// 
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
// 
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

#pragma once

#include "key.h"
#include "helpers.h"
#include <sodium.h>
#include <type_traits>

namespace sodium {

template <typename PK=bytes, typename SEED_TYPE=bytes_protected,
	typename T = typename std::enable_if<
	std::is_same<SEED_TYPE, sodium::bytes_protected>::value
	, int
	>::type
>
class keypair
{
  /**
   * The class sodium::keypair represents a pair of public key /
   * private key used in various public key cryptography functions of
   * the libsodium library.
   *
   * The public key is stored in PK (default unprotected sodium::bytes,
   * but could be changed to sodium::bytes_protected is desired),
   * while the private key, being sensitive, is stored in
   * sodium::bytes_protected memory, i.e. in an internal sodium::key
   * object.
   *
   * A keypair provides non-mutable data()/size() access to the bytes
   * of the public/private keys in a uniform fashion via the
   * public_key() and private_key() accessors.
   *
   * A keypair can be constructed randomly, or deterministically by
   * providing a seed. Furthermore, given a private key previously
   * generated by keypair or the underlying libsodium functions,
   * the corresponding public key can be derived and a keypair
   * constructed.
   **/

 public:
  // common constants for typical key and seed sizes
  static constexpr std::size_t KEYSIZE_PUBLIC_KEY  = crypto_box_PUBLICKEYBYTES;
  static constexpr std::size_t KEYSIZE_PRIVATE_KEY = crypto_box_SECRETKEYBYTES;
  static constexpr std::size_t KEYSIZE_SEEDBYTES   = crypto_box_SEEDBYTES;

  using private_key_type = key<KEYSIZE_PRIVATE_KEY>;
  using public_key_type  = PK;
  using seed_type = SEED_TYPE;

  /**
   * Generate a new (random) key pair of public/private keys.
   *
   * The created keypair contains a public key with KEYSIZE_PUBLIC_KEY bytes,
   * and a private key with KEYSIZE_PRIVATE_KEY bytes. Both keys are related
   * and must be used together.
   *
   * Underlying libsodium function: crypto_box_keypair().
   *
   * the private key is stored in an internal key object in protected
   * key_type memory (readonly). It will be wiped clean when the keypair
   * goes out of scope or is destroyed.
   *
   * The public key is stored in an internal bytes object in
   * unprotected (readwrite) memory.
   **/
  
  keypair()
    : public_key_(KEYSIZE_PUBLIC_KEY, '\0'), private_key_(false) {
    crypto_box_keypair(reinterpret_cast<unsigned char *>(public_key_.data()), private_key_.setdata());
    private_key_.readonly();
  }

  /**
   * Deterministically generate a key pair of public/private keys.
   *
   * The created keypair depends on a seed which must have KEYSIZE_SEEDBYTES
   * bytes. The same public/private keys will be generated for the same
   * seeds. Providing a seed of wrong size will throw a std::runtime_error.
   *
   * Underlying libsodium function: crypto_box_seed_keypair().
   *
   * Otherwise, see keypair().
   **/
  
  keypair(const seed_type &seed)
    : public_key_(KEYSIZE_PUBLIC_KEY, '\0'), private_key_(false) {
    if (seed.size() != KEYSIZE_SEEDBYTES)
      throw std::runtime_error {"sodium::keypair::keypair(seed) wrong seed size"};
    crypto_box_seed_keypair(reinterpret_cast<unsigned char *>(public_key_.data()),
		private_key_.setdata(),
		reinterpret_cast<const unsigned char *>(seed.data()));
    private_key_.readonly();
  }

  /**
   * Given a previously calculated private key whose privkey_size
   * bytes are stored starting at privkey_data, derive the
   * corresponding public key public_key, and construct with privkey_data
   * and pubkey a new keypair. private_key_data MUST point to
   * KEYSIZE_PRIVATE_KEY bytes as shown by privkey_size, of course, or
   * this constructor will throw a std::runtime_error. The bytes at
   * privkey_data must be accessible or readable, or the program will
   * terminate.
   *
   * Underlying libsodium function: crypto_scalarmult_base().
   *
   * Note that the bytes at privkey_data MUST have been generated by
   * calculation, i.e.  by calls to keypair() constructors or
   * underlying libsodium functions. Undefined behavior results if
   * this is not the case.
   *
   * Otherwise, see keypair().
   **/
  
  keypair(const byte *private_key_data, const std::size_t private_key_size)
    : public_key_(KEYSIZE_PUBLIC_KEY, '\0'), private_key_(false) {
    if (private_key_size != KEYSIZE_PRIVATE_KEY)
      throw std::runtime_error {"sodium::keypair::keypair(private_key_data, private_key_size) wrong private_key_size"};
    std::copy(private_key_data, private_key_data+private_key_size,
	      private_key_.setdata()); // constant time
    
    // public key can be reconstructed from private key
    // previously computed by crypto_box_[seed_]keypair()!
    crypto_scalarmult_base(reinterpret_cast<unsigned char *>(public_key_.data()), private_key_.data());

    private_key_.readonly();
  }

  /**
  * Copy and move constructors
  **/ 

  template <typename U>
  keypair(const keypair<U> &other) :
	  public_key_(other.public_key()),
	  private_key_(other.private_key())
  {}

  template <typename U>
  keypair(keypair<U> &&other) :
	  public_key_(std::move(other.public_key_)),
	  private_key_(std::move(other.private_key_))
  {}

  /**
   * Give const access to the stored private key as a key object.
   *
   * This can be used to access the bytes of the private key via a
   * non-mutable data()/size() interface like this:
   *   <SOME_KEYPAIR>.private_key().data(), <SOME_KEYPAIR>.private_key().size()
   **/

  const private_key_type& private_key() const { return private_key_; }

  /**
   * Give const access to the stored public key as a bytes object.
   *
   * This can be used to access the bytes of the public key via a
   * non-mutable data()/size() interface like this:
   *  <SOME_KEYPAIR>.public_key().data(), <SOME_KEYPAIR>.public_key().size()
   **/

  const public_key_type& public_key() const { return public_key_; }
  
 private:
  public_key_type  public_key_;
  private_key_type private_key_;
};

} // namespace sodium

template <typename PK1=sodium::bytes, typename PK2=sodium::bytes>
bool operator== (const sodium::keypair<PK1> &kp1, const sodium::keypair<PK2> &kp2)
{
	// Compare public keys and private keys in constant time:

	return 
		// selects sodium::compare<PK1,PK2>()
		sodium::compare(kp1.public_key(), kp2.public_key()) 
		&&
		// uses operator==(sodium::key<KEYSIZE_PRIVATE_KEY>,
		//                 sodium::key<KEYSIZE_PRIVATE_KEY>)
		kp1.private_key() == kp2.private_key();
}

template <typename PK1=sodium::bytes, typename PK2=sodium::bytes>
bool operator!= (const sodium::keypair<PK1> &kp1, const sodium::keypair<PK2> &kp2)
{
	return (!(kp1 == kp2));
}
